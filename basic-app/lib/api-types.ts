// *****************
// This file is copied from https://github.com/Niftory/niftory-services/blob/dev/packages/api/generated/nexus-typegen.ts
// Keep it in sync to reflect API schema updates. NEVER MODIFY MANUALLY
// *****************
/**
 * This file was generated by Nexus Schema
 * Do not make changes to this file directly
 */

import type { core } from "nexus";
declare global {
  interface NexusGenCustomInputMethods<TypeName extends string> {
    /**
     * The default rarity levels in the Niftory API.
     */
    simpleRarityLevel<FieldName extends string>(
      fieldName: FieldName,
      opts?: core.CommonInputFieldConfig<TypeName, FieldName>
    ): void; // "SimpleRarityLevel";
    /**
     * Status of this resource for user workflows.
     */
    status<FieldName extends string>(
      fieldName: FieldName,
      opts?: core.CommonInputFieldConfig<TypeName, FieldName>
    ): void; // "Status";
    /**
     * A currency that can be accepted for payment.
     */
    currency<FieldName extends string>(
      fieldName: FieldName,
      opts?: core.CommonInputFieldConfig<TypeName, FieldName>
    ): void; // "Currency";
    /**
     * The state of an item for sale.
     */
    saleProcessingState<FieldName extends string>(
      fieldName: FieldName,
      opts?: core.CommonInputFieldConfig<TypeName, FieldName>
    ): void; // "SaleProcessingState";
    /**
     * The blockchains supported by Niftory.
     */
    blockchain<FieldName extends string>(
      fieldName: FieldName,
      opts?: core.CommonInputFieldConfig<TypeName, FieldName>
    ): void; // "Blockchain";
    /**
     * Roles for users of the Niftory admin portal and APIs.
     */
    role<FieldName extends string>(
      fieldName: FieldName,
      opts?: core.CommonInputFieldConfig<TypeName, FieldName>
    ): void; // "Role";
    /**
     * The state of a listing.
     */
    listingState<FieldName extends string>(
      fieldName: FieldName,
      opts?: core.CommonInputFieldConfig<TypeName, FieldName>
    ): void; // "ListingState";
    /**
     * The state of a wallet.
     */
    walletState<FieldName extends string>(
      fieldName: FieldName,
      opts?: core.CommonInputFieldConfig<TypeName, FieldName>
    ): void; // "WalletState";
    /**
     * Represents the level of rarity of an NFT model.
     */
    rarity<FieldName extends string>(
      fieldName: FieldName,
      opts?: core.CommonInputFieldConfig<TypeName, FieldName>
    ): void; // "Rarity";
    /**
     * The pricing for a particular listing
     */
    pricing<FieldName extends string>(
      fieldName: FieldName,
      opts?: core.CommonInputFieldConfig<TypeName, FieldName>
    ): void; // "Pricing";
    /**
     * The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
     */
    json<FieldName extends string>(
      fieldName: FieldName,
      opts?: core.CommonInputFieldConfig<TypeName, FieldName>
    ): void; // "JSONObject";
    /**
     * Integers that will have a value greater than 0.
     */
    positiveInt<FieldName extends string>(
      fieldName: FieldName,
      opts?: core.CommonInputFieldConfig<TypeName, FieldName>
    ): void; // "PositiveInt";
    /**
     * A field whose value conforms to the standard URL format as specified in RFC3986: https://www.ietf.org/rfc/rfc3986.txt.
     */
    url<FieldName extends string>(
      fieldName: FieldName,
      opts?: core.CommonInputFieldConfig<TypeName, FieldName>
    ): void; // "URL";
    /**
     * A field whose value conforms to the standard internet email address format as specified in RFC822: https://www.w3.org/Protocols/rfc822/.
     */
    email<FieldName extends string>(
      fieldName: FieldName,
      opts?: core.CommonInputFieldConfig<TypeName, FieldName>
    ): void; // "EmailAddress";
    /**
     * The `Upload` scalar type represents a file upload.
     */
    upload<FieldName extends string>(
      fieldName: FieldName,
      opts?: core.CommonInputFieldConfig<TypeName, FieldName>
    ): void; // "Upload";
    /**
     * Floats that will have a value greater than 0.
     */
    positiveFloat<FieldName extends string>(
      fieldName: FieldName,
      opts?: core.CommonInputFieldConfig<TypeName, FieldName>
    ): void; // "PositiveFloat";
    /**
     * The input to create or update NFT content.
     */
    nftContentInput<FieldName extends string>(
      fieldName: FieldName,
      opts?: core.CommonInputFieldConfig<TypeName, FieldName>
    ): void; // "NFTContentInput";
    /**
     * The input to select a packaging model selection spec.
     */
    packagingModelSelectionInput<FieldName extends string>(
      fieldName: FieldName,
      opts?: core.CommonInputFieldConfig<TypeName, FieldName>
    ): void; // "PackagingModelSelectionInput";
    /**
     * The input to create a [packaging model selection filter]({{Types.PackagingModelSelectionFilter}}).
     */
    packagingModelSelectionFilterInput<FieldName extends string>(
      fieldName: FieldName,
      opts?: core.CommonInputFieldConfig<TypeName, FieldName>
    ): void; // "PackagingModelSelectionFilterInput";
    /**
     * The input to create a [packaging model packaging]({{Types.PackagingModelPackaging}}).
     */
    packagingModelPackagingInput<FieldName extends string>(
      fieldName: FieldName,
      opts?: core.CommonInputFieldConfig<TypeName, FieldName>
    ): void; // "PackagingModelPackagingInput";
    /**
     * The input to create a [packaging model rule]({{Types.PackagingModelRule}}).
     */
    packagingModelRuleInput<FieldName extends string>(
      fieldName: FieldName,
      opts?: core.CommonInputFieldConfig<TypeName, FieldName>
    ): void; // "PackagingModelRuleInput";
    /**
     * The input to create a [packaging model condition]({{Types.PackagingModelCondition}}).
     */
    packagingModelConditionInput<FieldName extends string>(
      fieldName: FieldName,
      opts?: core.CommonInputFieldConfig<TypeName, FieldName>
    ): void; // "PackagingModelConditionInput";
  }
}
declare global {
  interface NexusGenCustomOutputMethods<TypeName extends string> {
    /**
     * The default rarity levels in the Niftory API.
     */
    simpleRarityLevel<FieldName extends string>(
      fieldName: FieldName,
      ...opts: core.ScalarOutSpread<TypeName, FieldName>
    ): void; // "SimpleRarityLevel";
    /**
     * Status of this resource for user workflows.
     */
    status<FieldName extends string>(
      fieldName: FieldName,
      ...opts: core.ScalarOutSpread<TypeName, FieldName>
    ): void; // "Status";
    /**
     * A currency that can be accepted for payment.
     */
    currency<FieldName extends string>(
      fieldName: FieldName,
      ...opts: core.ScalarOutSpread<TypeName, FieldName>
    ): void; // "Currency";
    /**
     * The state of an item for sale.
     */
    saleProcessingState<FieldName extends string>(
      fieldName: FieldName,
      ...opts: core.ScalarOutSpread<TypeName, FieldName>
    ): void; // "SaleProcessingState";
    /**
     * The blockchains supported by Niftory.
     */
    blockchain<FieldName extends string>(
      fieldName: FieldName,
      ...opts: core.ScalarOutSpread<TypeName, FieldName>
    ): void; // "Blockchain";
    /**
     * Roles for users of the Niftory admin portal and APIs.
     */
    role<FieldName extends string>(
      fieldName: FieldName,
      ...opts: core.ScalarOutSpread<TypeName, FieldName>
    ): void; // "Role";
    /**
     * The state of a listing.
     */
    listingState<FieldName extends string>(
      fieldName: FieldName,
      ...opts: core.ScalarOutSpread<TypeName, FieldName>
    ): void; // "ListingState";
    /**
     * The state of a wallet.
     */
    walletState<FieldName extends string>(
      fieldName: FieldName,
      ...opts: core.ScalarOutSpread<TypeName, FieldName>
    ): void; // "WalletState";
    /**
     * An interface containing common data about files.
     */
    file<FieldName extends string>(
      fieldName: FieldName,
      ...opts: core.ScalarOutSpread<TypeName, FieldName>
    ): void; // "File";
    /**
     * Current Prisma Mapping: Entity. A non-fungible token on the blockchain.
     */
    nft<FieldName extends string>(
      fieldName: FieldName,
      ...opts: core.ScalarOutSpread<TypeName, FieldName>
    ): void; // "NFT";
    /**
     * Represents the level of rarity of an NFT model.
     */
    rarity<FieldName extends string>(
      fieldName: FieldName,
      ...opts: core.ScalarOutSpread<TypeName, FieldName>
    ): void; // "Rarity";
    /**
     * Current Prisma Mapping: Collectible. The definition of a type of NFT.
     */
    nftModel<FieldName extends string>(
      fieldName: FieldName,
      ...opts: core.ScalarOutSpread<TypeName, FieldName>
    ): void; // "NFTModel";
    /**
     * Current Prisma Mapping: Set. A set of NFT models.
     */
    set<FieldName extends string>(
      fieldName: FieldName,
      ...opts: core.ScalarOutSpread<TypeName, FieldName>
    ): void; // "NFTSet";
    /**
     * Current Prisma Mapping: PackListing. A model of how to select and package a group of NFTs.
     */
    packagingModel<FieldName extends string>(
      fieldName: FieldName,
      ...opts: core.ScalarOutSpread<TypeName, FieldName>
    ): void; // "PackagingModel";
    /**
     * Current Prisma Mapping: PackListing.packShape (rules), PackListing.collectibleIds, PackListing.setId (filters). Specifies the distribution of NFTs selected for packaging in a [PackagingModel]({{Types.PackagingModel}}).
     */
    packagingModelSelection<FieldName extends string>(
      fieldName: FieldName,
      ...opts: core.ScalarOutSpread<TypeName, FieldName>
    ): void; // "PackagingModelSelection";
    /**
     * Current Prisma Mapping: PackListing.collectibleIds, PackListing.setId. Filters to apply to all NFTs selected in a [PackagingModel]({{Types.PackagingModel}}).
     */
    packagingModelSelectionFilter<FieldName extends string>(
      fieldName: FieldName,
      ...opts: core.ScalarOutSpread<TypeName, FieldName>
    ): void; // "PackagingModelSelectionFilter";
    /**
     * Current Prisma Mapping: PackListing.files, PackListing.packShape. Specifies the distribution of NFTs in each package created in a [PackagingModel]({{Types.PackagingModel}}).
     */
    packagingModelPackaging<FieldName extends string>(
      fieldName: FieldName,
      ...opts: core.ScalarOutSpread<TypeName, FieldName>
    ): void; // "PackagingModelPackaging";
    /**
     * Current Prisma Mapping: PackListing.packShape. Specifies a group of NFTs that match one or more conditions
     */
    packagingModelRule<FieldName extends string>(
      fieldName: FieldName,
      ...opts: core.ScalarOutSpread<TypeName, FieldName>
    ): void; // "PackagingModelRule";
    /**
     * A condition to match NFTs against.
     */
    packagingModelCondition<FieldName extends string>(
      fieldName: FieldName,
      ...opts: core.ScalarOutSpread<TypeName, FieldName>
    ): void; // "PackagingModelCondition";
    /**
     * Current Prisma Mapping: Pack. One or more NFTs packaged for sale.
     */
    package<FieldName extends string>(
      fieldName: FieldName,
      ...opts: core.ScalarOutSpread<TypeName, FieldName>
    ): void; // "Package";
    /**
     * Current Prisma Mapping: PackListing. A listing of NFTs for sale.
     */
    listing<FieldName extends string>(
      fieldName: FieldName,
      ...opts: core.ScalarOutSpread<TypeName, FieldName>
    ): void; // "Listing";
    /**
     * The pricing for a particular listing
     */
    pricing<FieldName extends string>(
      fieldName: FieldName,
      ...opts: core.ScalarOutSpread<TypeName, FieldName>
    ): void; // "Pricing";
    /**
     * Current Prisma Mapping: File. A file uploaded to the Niftory API.
     */
    simpleFile<FieldName extends string>(
      fieldName: FieldName,
      ...opts: core.ScalarOutSpread<TypeName, FieldName>
    ): void; // "SimpleFile";
    /**
     * Current Prisma Mapping: File (with ipfsContentUrl and ipfsMetadataUrl). A file to be included in an NFT. Extends [File]({{Types.File}}) to includes the IPFS addresses for the content and metadata.
     */
    nftFile<FieldName extends string>(
      fieldName: FieldName,
      ...opts: core.ScalarOutSpread<TypeName, FieldName>
    ): void; // "NFTFile";
    /**
     * Current Prisma Mapping: CollectibleFile. Media content to be included in an NFT.
     */
    nftMedia<FieldName extends string>(
      fieldName: FieldName,
      ...opts: core.ScalarOutSpread<TypeName, FieldName>
    ): void; // "NFTMedia";
    /**
     * A mapping from a packaged item to a user.
     */
    packagedItemToUserMapping<FieldName extends string>(
      fieldName: FieldName,
      ...opts: core.ScalarOutSpread<TypeName, FieldName>
    ): void; // "PackagedItemToUserMapping";
    /**
     * Current Prisma Mapping: CollectibleContent. Current Prisma Mapping: CollectibleContent. The content for an NFT.
     */
    nftContent<FieldName extends string>(
      fieldName: FieldName,
      ...opts: core.ScalarOutSpread<TypeName, FieldName>
    ): void; // "NFTContent";
    /**
     * Current Prisma Mapping: Wallet. Represents a single wallet on the blockchain scoped to a particular app and user.
     */
    wallet<FieldName extends string>(
      fieldName: FieldName,
      ...opts: core.ScalarOutSpread<TypeName, FieldName>
    ): void; // "Wallet";
    /**
     * Current Prisma Mapping: User (with role = COLLECTOR). Represents an individual user within a particular Niftory app.
     */
    appUser<FieldName extends string>(
      fieldName: FieldName,
      ...opts: core.ScalarOutSpread<TypeName, FieldName>
    ): void; // "AppUser";
    /**
     * Current Prisma Mapping: User (User.collectorScore, User.entities, User.collections, User.airdrops). Represents a user's profile collecting NFTs in a Niftory app.
     */
    collectorProfile<FieldName extends string>(
      fieldName: FieldName,
      ...opts: core.ScalarOutSpread<TypeName, FieldName>
    ): void; // "CollectorProfile";
    /**
     * Current Prisma Mapping: SmartContractType. A contract on the blockchain
     */
    contract<FieldName extends string>(
      fieldName: FieldName,
      ...opts: core.ScalarOutSpread<TypeName, FieldName>
    ): void; // "Contract";
    /**
     * Current Prisma Mapping: Org.appClient. An app in the Niftory API.
     */
    app<FieldName extends string>(
      fieldName: FieldName,
      ...opts: core.ScalarOutSpread<TypeName, FieldName>
    ): void; // "App";
    /**
     * Current Prisma Mapping: Org. An org within the Niftory API.
     */
    org<FieldName extends string>(
      fieldName: FieldName,
      ...opts: core.ScalarOutSpread<TypeName, FieldName>
    ): void; // "Org";
    /**
     * Current Prisma Mapping: User (with role >= MARKETER). A user of the Niftory admin portal and APIs.
     */
    adminUser<FieldName extends string>(
      fieldName: FieldName,
      ...opts: core.ScalarOutSpread<TypeName, FieldName>
    ): void; // "AdminUser";
    /**
     * Maps a user to a role in an org
     */
    userRoleMapping<FieldName extends string>(
      fieldName: FieldName,
      ...opts: core.ScalarOutSpread<TypeName, FieldName>
    ): void; // "UserRoleMapping";
    /**
     * The response from initiating a purchase checkout.
     */
    initiateCheckoutResponse<FieldName extends string>(
      fieldName: FieldName,
      ...opts: core.ScalarOutSpread<TypeName, FieldName>
    ): void; // "InitiateCheckoutResponse";
    /**
     * The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
     */
    json<FieldName extends string>(
      fieldName: FieldName,
      ...opts: core.ScalarOutSpread<TypeName, FieldName>
    ): void; // "JSONObject";
    /**
     * Integers that will have a value greater than 0.
     */
    positiveInt<FieldName extends string>(
      fieldName: FieldName,
      ...opts: core.ScalarOutSpread<TypeName, FieldName>
    ): void; // "PositiveInt";
    /**
     * A field whose value conforms to the standard URL format as specified in RFC3986: https://www.ietf.org/rfc/rfc3986.txt.
     */
    url<FieldName extends string>(
      fieldName: FieldName,
      ...opts: core.ScalarOutSpread<TypeName, FieldName>
    ): void; // "URL";
    /**
     * A field whose value conforms to the standard internet email address format as specified in RFC822: https://www.w3.org/Protocols/rfc822/.
     */
    email<FieldName extends string>(
      fieldName: FieldName,
      ...opts: core.ScalarOutSpread<TypeName, FieldName>
    ): void; // "EmailAddress";
    /**
     * The `Upload` scalar type represents a file upload.
     */
    upload<FieldName extends string>(
      fieldName: FieldName,
      ...opts: core.ScalarOutSpread<TypeName, FieldName>
    ): void; // "Upload";
    /**
     * Floats that will have a value greater than 0.
     */
    positiveFloat<FieldName extends string>(
      fieldName: FieldName,
      ...opts: core.ScalarOutSpread<TypeName, FieldName>
    ): void; // "PositiveFloat";
  }
}

declare global {
  interface NexusGen extends NexusGenTypes {}
}

export interface NexusGenInputs {
  CreateListingInput: {
    // input type
    packages: Array<string | null>; // [ID]!
    price: NexusGenScalars["PositiveFloat"]; // PositiveFloat!
  };
  NFTContentInput: {
    // input type
    files?: Array<NexusGenScalars["Upload"] | null> | null; // [Upload]
    poster?: NexusGenScalars["Upload"] | null; // Upload
  };
  NFTModelCreateInput: {
    // input type
    description: string; // String!
    nftContent?: NexusGenInputs["NFTContentInput"] | null; // NFTContentInput
    quantity: NexusGenScalars["PositiveInt"]; // PositiveInt!
    rarity: NexusGenEnums["SimpleRarityLevel"]; // SimpleRarityLevel!
    setId: string; // ID!
    status?: NexusGenEnums["Status"] | null; // Status
    subtitle?: string | null; // String
    tags?: NexusGenScalars["JSONObject"] | null; // JSONObject
    title: string; // String!
  };
  NFTModelUpdateInput: {
    // input type
    description?: string | null; // String
    nftContent?: NexusGenInputs["NFTContentInput"] | null; // NFTContentInput
    quantity?: number | null; // Int
    rarity?: NexusGenEnums["SimpleRarityLevel"] | null; // SimpleRarityLevel
    status?: NexusGenEnums["Status"] | null; // Status
    subtitle?: string | null; // String
    tags?: NexusGenScalars["JSONObject"] | null; // JSONObject
    title?: string | null; // String
  };
  NFTSetCreateInput: {
    // input type
    image?: NexusGenScalars["Upload"] | null; // Upload
    status?: NexusGenEnums["Status"] | null; // Status
    tags?: NexusGenScalars["JSONObject"] | null; // JSONObject
    title: string; // String!
  };
  NFTSetUpdateInput: {
    // input type
    image?: NexusGenScalars["Upload"] | null; // Upload
    status?: NexusGenEnums["Status"] | null; // Status
    tags?: NexusGenScalars["JSONObject"] | null; // JSONObject
    title?: string | null; // String
  };
  PackagingModelConditionInput: {
    // input type
    rarity: NexusGenEnums["SimpleRarityLevel"]; // SimpleRarityLevel!
  };
  PackagingModelCreateInput: {
    // input type
    nftsPerPack: NexusGenScalars["PositiveInt"]; // PositiveInt!
    numberOfPacks: NexusGenScalars["PositiveInt"]; // PositiveInt!
    packaging?: NexusGenInputs["PackagingModelPackagingInput"] | null; // PackagingModelPackagingInput
    selection: NexusGenInputs["PackagingModelSelectionInput"]; // PackagingModelSelectionInput!
  };
  PackagingModelPackagingInput: {
    // input type
    image?: NexusGenScalars["Upload"] | null; // Upload
    rules?: Array<NexusGenInputs["PackagingModelRuleInput"] | null> | null; // [PackagingModelRuleInput]
  };
  PackagingModelRuleInput: {
    // input type
    conditions: Array<NexusGenInputs["PackagingModelConditionInput"] | null>; // [PackagingModelConditionInput]!
    number: NexusGenScalars["PositiveInt"]; // PositiveInt!
  };
  PackagingModelSelectionFilterInput: {
    // input type
    setId: string; // String!
  };
  PackagingModelSelectionInput: {
    // input type
    filters: Array<NexusGenInputs["PackagingModelSelectionFilterInput"] | null>; // [PackagingModelSelectionFilterInput]!
    rules?: Array<NexusGenInputs["PackagingModelRuleInput"] | null> | null; // [PackagingModelRuleInput]
  };
  PackagingModelUpdateInput: {
    // input type
    nftsPerPack?: NexusGenScalars["PositiveInt"] | null; // PositiveInt
    numberOfPacks?: NexusGenScalars["PositiveInt"] | null; // PositiveInt
    packaging?: NexusGenInputs["PackagingModelPackagingInput"] | null; // PackagingModelPackagingInput
    selection?: NexusGenInputs["PackagingModelSelectionInput"] | null; // PackagingModelSelectionInput
  };
  UpdateListingInput: {
    // input type
    packages?: Array<string | null> | null; // [ID]
    price?: NexusGenScalars["PositiveFloat"] | null; // PositiveFloat
  };
}

export interface NexusGenEnums {
  Blockchain: "ETHEREUM" | "FLOW" | "POLYGON";
  Currency: "USD";
  ListingState: "ACTIVE" | "COMPLETED" | "INACTIVE";
  Role: "ADMINISTRATOR" | "CREATOR" | "MANAGER" | "MINTER";
  SaleProcessingState:
    | "AVAILABLE"
    | "CREATED"
    | "ERROR"
    | "LOCKED"
    | "RESERVED"
    | "SOLD"
    | "TRANSFERRING";
  SimpleRarityLevel: "COMMON" | "LEGENDARY" | "RARE";
  Status: "DONE" | "DRAFT" | "IN_PROGRESS" | "TO_DO";
  WalletState: "READY" | "UNVERIFIED" | "VERIFIED";
}

export interface NexusGenScalars {
  String: string;
  Int: number;
  Float: number;
  Boolean: boolean;
  ID: string;
  EmailAddress: any;
  JSONObject: any;
  PositiveFloat: any;
  PositiveInt: any;
  URL: any;
  Upload: any;
}

export interface NexusGenObjects {
  AdminUser: {
    // root type
    email?: NexusGenScalars["EmailAddress"] | null; // EmailAddress
    id: string; // ID!
    image?: string | null; // String
    name?: string | null; // String
    orgs?: Array<NexusGenRootTypes["UserRoleMapping"] | null> | null; // [UserRoleMapping]
  };
  Airdrop: {
    // root type
    description?: string | null; // String
    recipients?: Array<
      NexusGenRootTypes["PackagedItemToUserMapping"] | null
    > | null; // [PackagedItemToUserMapping]
    status?: NexusGenEnums["Status"] | null; // Status
    tags?: NexusGenScalars["JSONObject"] | null; // JSONObject
    title?: string | null; // String
  };
  App: {
    // root type
    contract?: NexusGenRootTypes["Contract"] | null; // Contract
    id: string; // ID!
    org?: NexusGenRootTypes["Org"] | null; // Org
  };
  AppUser: {
    // root type
    app?: NexusGenRootTypes["App"] | null; // App
    collectorProfile?: NexusGenRootTypes["CollectorProfile"] | null; // CollectorProfile
    email?: NexusGenScalars["EmailAddress"] | null; // EmailAddress
    id: string; // ID!
    image?: string | null; // String
    name?: string | null; // String
    wallet?: NexusGenRootTypes["Wallet"] | null; // Wallet
  };
  CollectorProfile: {
    // root type
    score?: number | null; // Int
  };
  Contract: {
    // root type
    address?: string | null; // String
    blockchain?: NexusGenEnums["Blockchain"] | null; // Blockchain
    id: string; // ID!
  };
  InitiateCheckoutResponse: {
    // root type
    redirectUrl?: NexusGenScalars["URL"] | null; // URL
  };
  Listing: {
    // root type
    id: string; // ID!
    packages?: Array<NexusGenRootTypes["Package"] | null> | null; // [Package]
    pricing?: NexusGenRootTypes["Pricing"] | null; // Pricing
    state?: NexusGenEnums["ListingState"] | null; // ListingState
    status?: NexusGenEnums["Status"] | null; // Status
    tags?: NexusGenScalars["JSONObject"] | null; // JSONObject
  };
  Mutation: {};
  NFT: {
    // root type
    blockchainId?: string | null; // String
    id: string; // ID!
    metadata?: NexusGenScalars["JSONObject"] | null; // JSONObject
    model?: NexusGenRootTypes["NFTModel"] | null; // NFTModel
    serialNumber?: number | null; // Int
    wallet?: NexusGenRootTypes["Wallet"] | null; // Wallet
  };
  NFTContent: {
    // root type
    files?: Array<NexusGenRootTypes["NFTMedia"] | null> | null; // [NFTMedia]
    poster?: NexusGenRootTypes["NFTFile"] | null; // NFTFile
  };
  NFTFile: {
    // root type
    contentType: string; // String!
    ipfsContentAddress: string; // String!
    ipfsMetadataAddress: string; // String!
    url: NexusGenScalars["URL"]; // URL!
  };
  NFTMedia: {
    // root type
    media: NexusGenRootTypes["NFTFile"]; // NFTFile!
    thumbnail?: NexusGenRootTypes["File"] | null; // File
  };
  NFTModel: {
    // root type
    blockchainId?: string | null; // String
    content?: NexusGenRootTypes["NFTContent"] | null; // NFTContent
    description: string; // String!
    id: string; // ID!
    metadata?: NexusGenScalars["JSONObject"] | null; // JSONObject
    nfts?: Array<NexusGenRootTypes["NFT"] | null> | null; // [NFT]
    quantity: NexusGenScalars["PositiveInt"]; // PositiveInt!
    rarity: NexusGenRootTypes["Rarity"]; // Rarity!
    set: NexusGenRootTypes["NFTSet"]; // NFTSet!
    status?: NexusGenEnums["Status"] | null; // Status
    subtitle?: string | null; // String
    tags?: NexusGenScalars["JSONObject"] | null; // JSONObject
    title: string; // String!
  };
  NFTSet: {
    // root type
    app?: NexusGenRootTypes["App"] | null; // App
    blockchainId?: string | null; // String
    id: string; // ID!
    image?: NexusGenScalars["URL"] | null; // URL
    metadata?: NexusGenScalars["JSONObject"] | null; // JSONObject
    models?: Array<NexusGenRootTypes["NFTModel"] | null> | null; // [NFTModel]
    status?: NexusGenEnums["Status"] | null; // Status
    tags?: NexusGenScalars["JSONObject"] | null; // JSONObject
    title: string; // String!
  };
  Org: {
    // root type
    apps?: Array<NexusGenRootTypes["App"] | null> | null; // [App]
    id: string; // ID!
    members?: Array<NexusGenRootTypes["AdminUser"] | null> | null; // [AdminUser]
  };
  Package: {
    // root type
    buyer?: NexusGenRootTypes["AppUser"] | null; // AppUser
    contents?: Array<NexusGenRootTypes["NFT"] | null> | null; // [NFT]
    id: string; // ID!
    image?: string | null; // String
    saleProcessingState: NexusGenEnums["SaleProcessingState"]; // SaleProcessingState!
  };
  PackagedItemToUserMapping: {
    // root type
    package?: NexusGenRootTypes["Package"] | null; // Package
    user?: NexusGenRootTypes["AppUser"] | null; // AppUser
  };
  PackagingModel: {
    // root type
    id: string; // ID!
    nftsPerPack?: NexusGenScalars["PositiveInt"] | null; // PositiveInt
    numberOfPacks?: NexusGenScalars["PositiveInt"] | null; // PositiveInt
    packages?: Array<NexusGenRootTypes["Package"] | null> | null; // [Package]
    packaging?: NexusGenRootTypes["PackagingModelPackaging"] | null; // PackagingModelPackaging
    selection?: NexusGenRootTypes["PackagingModelSelection"] | null; // PackagingModelSelection
    status?: NexusGenEnums["Status"] | null; // Status
    tags?: NexusGenScalars["JSONObject"] | null; // JSONObject
  };
  PackagingModelCondition: {
    // root type
    rarity: NexusGenRootTypes["Rarity"]; // Rarity!
  };
  PackagingModelPackaging: {
    // root type
    image?: NexusGenScalars["URL"] | null; // URL
    rules?: Array<NexusGenRootTypes["PackagingModelRule"] | null> | null; // [PackagingModelRule]
  };
  PackagingModelRule: {
    // root type
    conditions: Array<NexusGenRootTypes["PackagingModelCondition"] | null>; // [PackagingModelCondition]!
    number: NexusGenScalars["PositiveInt"]; // PositiveInt!
  };
  PackagingModelSelection: {
    // root type
    filters: Array<NexusGenRootTypes["PackagingModelSelectionFilter"] | null>; // [PackagingModelSelectionFilter]!
    rules?: Array<NexusGenRootTypes["PackagingModelRule"] | null> | null; // [PackagingModelRule]
  };
  PackagingModelSelectionFilter: {
    // root type
    setId: string; // String!
  };
  Query: {};
  SimpleFile: {
    // root type
    contentType: string; // String!
    url: NexusGenScalars["URL"]; // URL!
  };
  SimplePricing: {
    // root type
    currency: NexusGenEnums["Currency"]; // Currency!
    price: NexusGenScalars["PositiveFloat"]; // PositiveFloat!
  };
  SimpleRarity: {
    // root type
    level?: NexusGenEnums["SimpleRarityLevel"] | null; // SimpleRarityLevel
  };
  UserRoleMapping: {
    // root type
    org?: NexusGenRootTypes["Org"] | null; // Org
    role?: NexusGenEnums["Role"] | null; // Role
    userId: string; // String!
  };
  Wallet: {
    // root type
    address: string; // String!
    blob?: NexusGenScalars["JSONObject"] | null; // JSONObject
    cid?: string | null; // String
    id: string; // ID!
    nfts?: Array<NexusGenRootTypes["NFT"] | null> | null; // [NFT]
    state: NexusGenEnums["WalletState"]; // WalletState!
    verificationCode?: string | null; // String
  };
}

export interface NexusGenInterfaces {
  BlockchainEntity:
    | core.Discriminate<"NFT", "required">
    | core.Discriminate<"NFTModel", "required">
    | core.Discriminate<"NFTSet", "required">;
  BlockchainResource:
    | core.Discriminate<"NFTModel", "required">
    | core.Discriminate<"NFTSet", "required">;
  File:
    | core.Discriminate<"NFTFile", "required">
    | core.Discriminate<"SimpleFile", "required">;
  Identifiable:
    | core.Discriminate<"AdminUser", "required">
    | core.Discriminate<"App", "required">
    | core.Discriminate<"AppUser", "required">
    | core.Discriminate<"Contract", "required">
    | core.Discriminate<"Listing", "required">
    | core.Discriminate<"NFT", "required">
    | core.Discriminate<"NFTModel", "required">
    | core.Discriminate<"NFTSet", "required">
    | core.Discriminate<"Org", "required">
    | core.Discriminate<"Package", "required">
    | core.Discriminate<"PackagingModel", "required">
    | core.Discriminate<"Wallet", "required">;
  Resource:
    | core.Discriminate<"Airdrop", "required">
    | core.Discriminate<"Listing", "required">
    | core.Discriminate<"NFTModel", "required">
    | core.Discriminate<"NFTSet", "required">
    | core.Discriminate<"PackagingModel", "required">;
  UserData:
    | core.Discriminate<"AdminUser", "required">
    | core.Discriminate<"AppUser", "required">;
}

export interface NexusGenUnions {
  Pricing: core.Discriminate<"SimplePricing", "required">;
  Rarity: core.Discriminate<"SimpleRarity", "required">;
}

export type NexusGenRootTypes = NexusGenInterfaces &
  NexusGenObjects &
  NexusGenUnions;

export type NexusGenAllTypes = NexusGenRootTypes &
  NexusGenScalars &
  NexusGenEnums;

export interface NexusGenFieldTypes {
  AdminUser: {
    // field return type
    email: NexusGenScalars["EmailAddress"] | null; // EmailAddress
    id: string; // ID!
    image: string | null; // String
    name: string | null; // String
    orgs: Array<NexusGenRootTypes["UserRoleMapping"] | null> | null; // [UserRoleMapping]
  };
  Airdrop: {
    // field return type
    description: string | null; // String
    recipients: Array<
      NexusGenRootTypes["PackagedItemToUserMapping"] | null
    > | null; // [PackagedItemToUserMapping]
    status: NexusGenEnums["Status"] | null; // Status
    tags: NexusGenScalars["JSONObject"] | null; // JSONObject
    title: string | null; // String
  };
  App: {
    // field return type
    contract: NexusGenRootTypes["Contract"] | null; // Contract
    id: string; // ID!
    org: NexusGenRootTypes["Org"] | null; // Org
  };
  AppUser: {
    // field return type
    app: NexusGenRootTypes["App"] | null; // App
    collectorProfile: NexusGenRootTypes["CollectorProfile"] | null; // CollectorProfile
    email: NexusGenScalars["EmailAddress"] | null; // EmailAddress
    id: string; // ID!
    image: string | null; // String
    name: string | null; // String
    wallet: NexusGenRootTypes["Wallet"] | null; // Wallet
  };
  CollectorProfile: {
    // field return type
    score: number | null; // Int
  };
  Contract: {
    // field return type
    address: string | null; // String
    blockchain: NexusGenEnums["Blockchain"] | null; // Blockchain
    id: string; // ID!
  };
  InitiateCheckoutResponse: {
    // field return type
    redirectUrl: NexusGenScalars["URL"] | null; // URL
  };
  Listing: {
    // field return type
    id: string; // ID!
    packages: Array<NexusGenRootTypes["Package"] | null> | null; // [Package]
    pricing: NexusGenRootTypes["Pricing"] | null; // Pricing
    state: NexusGenEnums["ListingState"] | null; // ListingState
    status: NexusGenEnums["Status"] | null; // Status
    tags: NexusGenScalars["JSONObject"] | null; // JSONObject
  };
  Mutation: {
    // field return type
    activateListing: NexusGenRootTypes["Listing"] | null; // Listing
    checkout: NexusGenRootTypes["InitiateCheckoutResponse"] | null; // InitiateCheckoutResponse
    createListing: NexusGenRootTypes["Listing"] | null; // Listing
    createModel: NexusGenRootTypes["NFTModel"] | null; // NFTModel
    createPackagingModel: NexusGenRootTypes["PackagingModel"] | null; // PackagingModel
    createSet: NexusGenRootTypes["NFTSet"] | null; // NFTSet
    deactivateListing: NexusGenRootTypes["Listing"] | null; // Listing
    mintModel: NexusGenRootTypes["NFTModel"] | null; // NFTModel
    mintNFT: NexusGenRootTypes["NFT"] | null; // NFT
    package: NexusGenRootTypes["PackagingModel"] | null; // PackagingModel
    readyWallet: NexusGenRootTypes["Wallet"] | null; // Wallet
    registerWallet: NexusGenRootTypes["Wallet"] | null; // Wallet
    reserve: NexusGenRootTypes["Package"] | null; // Package
    transfer: NexusGenRootTypes["NFT"] | null; // NFT
    updateListing: NexusGenRootTypes["Listing"] | null; // Listing
    updateModel: NexusGenRootTypes["NFTModel"] | null; // NFTModel
    updatePackagingModel: NexusGenRootTypes["PackagingModel"] | null; // PackagingModel
    updateSet: NexusGenRootTypes["NFTSet"] | null; // NFTSet
    verifyWallet: NexusGenRootTypes["Wallet"] | null; // Wallet
  };
  NFT: {
    // field return type
    blockchainId: string | null; // String
    id: string; // ID!
    metadata: NexusGenScalars["JSONObject"] | null; // JSONObject
    model: NexusGenRootTypes["NFTModel"] | null; // NFTModel
    serialNumber: number | null; // Int
    wallet: NexusGenRootTypes["Wallet"] | null; // Wallet
  };
  NFTContent: {
    // field return type
    files: Array<NexusGenRootTypes["NFTMedia"] | null> | null; // [NFTMedia]
    poster: NexusGenRootTypes["NFTFile"] | null; // NFTFile
  };
  NFTFile: {
    // field return type
    contentType: string; // String!
    ipfsContentAddress: string; // String!
    ipfsMetadataAddress: string; // String!
    url: NexusGenScalars["URL"]; // URL!
  };
  NFTMedia: {
    // field return type
    media: NexusGenRootTypes["NFTFile"]; // NFTFile!
    thumbnail: NexusGenRootTypes["File"] | null; // File
  };
  NFTModel: {
    // field return type
    blockchainId: string | null; // String
    content: NexusGenRootTypes["NFTContent"] | null; // NFTContent
    description: string; // String!
    id: string; // ID!
    metadata: NexusGenScalars["JSONObject"] | null; // JSONObject
    nfts: Array<NexusGenRootTypes["NFT"] | null> | null; // [NFT]
    quantity: NexusGenScalars["PositiveInt"]; // PositiveInt!
    rarity: NexusGenRootTypes["Rarity"]; // Rarity!
    set: NexusGenRootTypes["NFTSet"]; // NFTSet!
    status: NexusGenEnums["Status"] | null; // Status
    subtitle: string | null; // String
    tags: NexusGenScalars["JSONObject"] | null; // JSONObject
    title: string; // String!
  };
  NFTSet: {
    // field return type
    app: NexusGenRootTypes["App"] | null; // App
    blockchainId: string | null; // String
    id: string; // ID!
    image: NexusGenScalars["URL"] | null; // URL
    metadata: NexusGenScalars["JSONObject"] | null; // JSONObject
    models: Array<NexusGenRootTypes["NFTModel"] | null> | null; // [NFTModel]
    status: NexusGenEnums["Status"] | null; // Status
    tags: NexusGenScalars["JSONObject"] | null; // JSONObject
    title: string; // String!
  };
  Org: {
    // field return type
    apps: Array<NexusGenRootTypes["App"] | null> | null; // [App]
    id: string; // ID!
    members: Array<NexusGenRootTypes["AdminUser"] | null> | null; // [AdminUser]
  };
  Package: {
    // field return type
    buyer: NexusGenRootTypes["AppUser"] | null; // AppUser
    contents: Array<NexusGenRootTypes["NFT"] | null> | null; // [NFT]
    id: string; // ID!
    image: string | null; // String
    saleProcessingState: NexusGenEnums["SaleProcessingState"]; // SaleProcessingState!
  };
  PackagedItemToUserMapping: {
    // field return type
    package: NexusGenRootTypes["Package"] | null; // Package
    user: NexusGenRootTypes["AppUser"] | null; // AppUser
  };
  PackagingModel: {
    // field return type
    id: string; // ID!
    nftsPerPack: NexusGenScalars["PositiveInt"] | null; // PositiveInt
    numberOfPacks: NexusGenScalars["PositiveInt"] | null; // PositiveInt
    packages: Array<NexusGenRootTypes["Package"] | null> | null; // [Package]
    packaging: NexusGenRootTypes["PackagingModelPackaging"] | null; // PackagingModelPackaging
    selection: NexusGenRootTypes["PackagingModelSelection"] | null; // PackagingModelSelection
    status: NexusGenEnums["Status"] | null; // Status
    tags: NexusGenScalars["JSONObject"] | null; // JSONObject
  };
  PackagingModelCondition: {
    // field return type
    rarity: NexusGenRootTypes["Rarity"]; // Rarity!
  };
  PackagingModelPackaging: {
    // field return type
    image: NexusGenScalars["URL"] | null; // URL
    rules: Array<NexusGenRootTypes["PackagingModelRule"] | null> | null; // [PackagingModelRule]
  };
  PackagingModelRule: {
    // field return type
    conditions: Array<NexusGenRootTypes["PackagingModelCondition"] | null>; // [PackagingModelCondition]!
    number: NexusGenScalars["PositiveInt"]; // PositiveInt!
  };
  PackagingModelSelection: {
    // field return type
    filters: Array<NexusGenRootTypes["PackagingModelSelectionFilter"] | null>; // [PackagingModelSelectionFilter]!
    rules: Array<NexusGenRootTypes["PackagingModelRule"] | null> | null; // [PackagingModelRule]
  };
  PackagingModelSelectionFilter: {
    // field return type
    setId: string; // String!
  };
  Query: {
    // field return type
    adminUser: NexusGenRootTypes["AdminUser"] | null; // AdminUser
    app: NexusGenRootTypes["App"] | null; // App
    appUser: NexusGenRootTypes["AppUser"] | null; // AppUser
    contract: NexusGenRootTypes["Contract"] | null; // Contract
    listing: NexusGenRootTypes["Listing"] | null; // Listing
    nft: NexusGenRootTypes["NFT"] | null; // NFT
    nftModel: NexusGenRootTypes["NFTModel"] | null; // NFTModel
    org: NexusGenRootTypes["Org"] | null; // Org
    packagingModel: NexusGenRootTypes["PackagingModel"] | null; // PackagingModel
    previewPackages: Array<NexusGenRootTypes["Package"] | null> | null; // [Package]
    set: NexusGenRootTypes["NFTSet"] | null; // NFTSet
    wallet: NexusGenRootTypes["Wallet"] | null; // Wallet
    walletByAddress: NexusGenRootTypes["Wallet"] | null; // Wallet
    walletByUserId: NexusGenRootTypes["Wallet"] | null; // Wallet
  };
  SimpleFile: {
    // field return type
    contentType: string; // String!
    url: NexusGenScalars["URL"]; // URL!
  };
  SimplePricing: {
    // field return type
    currency: NexusGenEnums["Currency"]; // Currency!
    price: NexusGenScalars["PositiveFloat"]; // PositiveFloat!
  };
  SimpleRarity: {
    // field return type
    level: NexusGenEnums["SimpleRarityLevel"] | null; // SimpleRarityLevel
  };
  UserRoleMapping: {
    // field return type
    org: NexusGenRootTypes["Org"] | null; // Org
    role: NexusGenEnums["Role"] | null; // Role
    userId: string; // String!
  };
  Wallet: {
    // field return type
    address: string; // String!
    blob: NexusGenScalars["JSONObject"] | null; // JSONObject
    cid: string | null; // String
    id: string; // ID!
    nfts: Array<NexusGenRootTypes["NFT"] | null> | null; // [NFT]
    state: NexusGenEnums["WalletState"]; // WalletState!
    verificationCode: string | null; // String
  };
  BlockchainEntity: {
    // field return type
    blockchainId: string | null; // String
    metadata: NexusGenScalars["JSONObject"] | null; // JSONObject
  };
  BlockchainResource: {
    // field return type
    blockchainId: string | null; // String
    metadata: NexusGenScalars["JSONObject"] | null; // JSONObject
    status: NexusGenEnums["Status"] | null; // Status
    tags: NexusGenScalars["JSONObject"] | null; // JSONObject
  };
  File: {
    // field return type
    contentType: string; // String!
    url: NexusGenScalars["URL"]; // URL!
  };
  Identifiable: {
    // field return type
    id: string; // ID!
  };
  Resource: {
    // field return type
    status: NexusGenEnums["Status"] | null; // Status
    tags: NexusGenScalars["JSONObject"] | null; // JSONObject
  };
  UserData: {
    // field return type
    email: NexusGenScalars["EmailAddress"] | null; // EmailAddress
    image: string | null; // String
    name: string | null; // String
  };
}

export interface NexusGenFieldTypeNames {
  AdminUser: {
    // field return type name
    email: "EmailAddress";
    id: "ID";
    image: "String";
    name: "String";
    orgs: "UserRoleMapping";
  };
  Airdrop: {
    // field return type name
    description: "String";
    recipients: "PackagedItemToUserMapping";
    status: "Status";
    tags: "JSONObject";
    title: "String";
  };
  App: {
    // field return type name
    contract: "Contract";
    id: "ID";
    org: "Org";
  };
  AppUser: {
    // field return type name
    app: "App";
    collectorProfile: "CollectorProfile";
    email: "EmailAddress";
    id: "ID";
    image: "String";
    name: "String";
    wallet: "Wallet";
  };
  CollectorProfile: {
    // field return type name
    score: "Int";
  };
  Contract: {
    // field return type name
    address: "String";
    blockchain: "Blockchain";
    id: "ID";
  };
  InitiateCheckoutResponse: {
    // field return type name
    redirectUrl: "URL";
  };
  Listing: {
    // field return type name
    id: "ID";
    packages: "Package";
    pricing: "Pricing";
    state: "ListingState";
    status: "Status";
    tags: "JSONObject";
  };
  Mutation: {
    // field return type name
    activateListing: "Listing";
    checkout: "InitiateCheckoutResponse";
    createListing: "Listing";
    createModel: "NFTModel";
    createPackagingModel: "PackagingModel";
    createSet: "NFTSet";
    deactivateListing: "Listing";
    mintModel: "NFTModel";
    mintNFT: "NFT";
    package: "PackagingModel";
    readyWallet: "Wallet";
    registerWallet: "Wallet";
    reserve: "Package";
    transfer: "NFT";
    updateListing: "Listing";
    updateModel: "NFTModel";
    updatePackagingModel: "PackagingModel";
    updateSet: "NFTSet";
    verifyWallet: "Wallet";
  };
  NFT: {
    // field return type name
    blockchainId: "String";
    id: "ID";
    metadata: "JSONObject";
    model: "NFTModel";
    serialNumber: "Int";
    wallet: "Wallet";
  };
  NFTContent: {
    // field return type name
    files: "NFTMedia";
    poster: "NFTFile";
  };
  NFTFile: {
    // field return type name
    contentType: "String";
    ipfsContentAddress: "String";
    ipfsMetadataAddress: "String";
    url: "URL";
  };
  NFTMedia: {
    // field return type name
    media: "NFTFile";
    thumbnail: "File";
  };
  NFTModel: {
    // field return type name
    blockchainId: "String";
    content: "NFTContent";
    description: "String";
    id: "ID";
    metadata: "JSONObject";
    nfts: "NFT";
    quantity: "PositiveInt";
    rarity: "Rarity";
    set: "NFTSet";
    status: "Status";
    subtitle: "String";
    tags: "JSONObject";
    title: "String";
  };
  NFTSet: {
    // field return type name
    app: "App";
    blockchainId: "String";
    id: "ID";
    image: "URL";
    metadata: "JSONObject";
    models: "NFTModel";
    status: "Status";
    tags: "JSONObject";
    title: "String";
  };
  Org: {
    // field return type name
    apps: "App";
    id: "ID";
    members: "AdminUser";
  };
  Package: {
    // field return type name
    buyer: "AppUser";
    contents: "NFT";
    id: "ID";
    image: "String";
    saleProcessingState: "SaleProcessingState";
  };
  PackagedItemToUserMapping: {
    // field return type name
    package: "Package";
    user: "AppUser";
  };
  PackagingModel: {
    // field return type name
    id: "ID";
    nftsPerPack: "PositiveInt";
    numberOfPacks: "PositiveInt";
    packages: "Package";
    packaging: "PackagingModelPackaging";
    selection: "PackagingModelSelection";
    status: "Status";
    tags: "JSONObject";
  };
  PackagingModelCondition: {
    // field return type name
    rarity: "Rarity";
  };
  PackagingModelPackaging: {
    // field return type name
    image: "URL";
    rules: "PackagingModelRule";
  };
  PackagingModelRule: {
    // field return type name
    conditions: "PackagingModelCondition";
    number: "PositiveInt";
  };
  PackagingModelSelection: {
    // field return type name
    filters: "PackagingModelSelectionFilter";
    rules: "PackagingModelRule";
  };
  PackagingModelSelectionFilter: {
    // field return type name
    setId: "String";
  };
  Query: {
    // field return type name
    adminUser: "AdminUser";
    app: "App";
    appUser: "AppUser";
    contract: "Contract";
    listing: "Listing";
    nft: "NFT";
    nftModel: "NFTModel";
    org: "Org";
    packagingModel: "PackagingModel";
    previewPackages: "Package";
    set: "NFTSet";
    wallet: "Wallet";
    walletByAddress: "Wallet";
    walletByUserId: "Wallet";
  };
  SimpleFile: {
    // field return type name
    contentType: "String";
    url: "URL";
  };
  SimplePricing: {
    // field return type name
    currency: "Currency";
    price: "PositiveFloat";
  };
  SimpleRarity: {
    // field return type name
    level: "SimpleRarityLevel";
  };
  UserRoleMapping: {
    // field return type name
    org: "Org";
    role: "Role";
    userId: "String";
  };
  Wallet: {
    // field return type name
    address: "String";
    blob: "JSONObject";
    cid: "String";
    id: "ID";
    nfts: "NFT";
    state: "WalletState";
    verificationCode: "String";
  };
  BlockchainEntity: {
    // field return type name
    blockchainId: "String";
    metadata: "JSONObject";
  };
  BlockchainResource: {
    // field return type name
    blockchainId: "String";
    metadata: "JSONObject";
    status: "Status";
    tags: "JSONObject";
  };
  File: {
    // field return type name
    contentType: "String";
    url: "URL";
  };
  Identifiable: {
    // field return type name
    id: "ID";
  };
  Resource: {
    // field return type name
    status: "Status";
    tags: "JSONObject";
  };
  UserData: {
    // field return type name
    email: "EmailAddress";
    image: "String";
    name: "String";
  };
}

export interface NexusGenArgTypes {
  Mutation: {
    activateListing: {
      // args
      id: string; // ID!
    };
    checkout: {
      // args
      failureRedirectUrl: string; // String!
      packageId: string; // ID!
      successRedirectUrl: string; // String!
    };
    createListing: {
      // args
      data: NexusGenInputs["CreateListingInput"]; // CreateListingInput!
    };
    createModel: {
      // args
      data: NexusGenInputs["NFTModelCreateInput"]; // NFTModelCreateInput!
    };
    createPackagingModel: {
      // args
      data: NexusGenInputs["PackagingModelCreateInput"]; // PackagingModelCreateInput!
    };
    createSet: {
      // args
      data: NexusGenInputs["NFTSetCreateInput"]; // NFTSetCreateInput!
    };
    deactivateListing: {
      // args
      id: string; // ID!
    };
    mintModel: {
      // args
      modelId: string; // ID!
      quantity?: NexusGenScalars["PositiveInt"] | null; // PositiveInt
    };
    mintNFT: {
      // args
      id: string; // ID!
    };
    package: {
      // args
      packagingModelId: string; // ID!
    };
    readyWallet: {
      // args
      address: string; // String!
    };
    registerWallet: {
      // args
      address: string; // String!
    };
    reserve: {
      // args
      listingId: string; // ID!
    };
    transfer: {
      // args
      id: string; // ID!
      walletId: string; // ID!
    };
    updateListing: {
      // args
      data: NexusGenInputs["UpdateListingInput"]; // UpdateListingInput!
    };
    updateModel: {
      // args
      data: NexusGenInputs["NFTModelUpdateInput"]; // NFTModelUpdateInput!
      id: string; // ID!
    };
    updatePackagingModel: {
      // args
      data: NexusGenInputs["PackagingModelCreateInput"]; // PackagingModelCreateInput!
    };
    updateSet: {
      // args
      data: NexusGenInputs["NFTSetCreateInput"]; // NFTSetCreateInput!
      id: string; // ID!
    };
    verifyWallet: {
      // args
      address: string; // String!
      signedVerificationCode: string; // String!
    };
  };
  Query: {
    adminUser: {
      // args
      id: string; // String!
    };
    app: {
      // args
      id?: string | null; // String
      name?: string | null; // String
    };
    appUser: {
      // args
      id: string; // String!
    };
    contract: {
      // args
      id?: string | null; // String
    };
    listing: {
      // args
      id: string; // String!
    };
    nft: {
      // args
      id: string; // String!
    };
    nftModel: {
      // args
      id: string; // String!
    };
    org: {
      // args
      id?: string | null; // String
    };
    packagingModel: {
      // args
      id: string; // String!
    };
    previewPackages: {
      // args
      id: string; // ID!
    };
    set: {
      // args
      id: string; // String!
    };
    wallet: {
      // args
      id: string; // String!
    };
    walletByAddress: {
      // args
      address: string; // String!
      appId?: string | null; // String
      userId?: string | null; // String
    };
    walletByUserId: {
      // args
      id: string; // String!
    };
  };
}

export interface NexusGenAbstractTypeMembers {
  Pricing: "SimplePricing";
  Rarity: "SimpleRarity";
  BlockchainEntity: "NFT" | "NFTModel" | "NFTSet";
  BlockchainResource: "NFTModel" | "NFTSet";
  File: "NFTFile" | "SimpleFile";
  Identifiable:
    | "AdminUser"
    | "App"
    | "AppUser"
    | "Contract"
    | "Listing"
    | "NFT"
    | "NFTModel"
    | "NFTSet"
    | "Org"
    | "Package"
    | "PackagingModel"
    | "Wallet";
  Resource: "Airdrop" | "Listing" | "NFTModel" | "NFTSet" | "PackagingModel";
  UserData: "AdminUser" | "AppUser";
}

export interface NexusGenTypeInterfaces {
  AdminUser: "Identifiable" | "UserData";
  Airdrop: "Resource";
  App: "Identifiable";
  AppUser: "Identifiable" | "UserData";
  Contract: "Identifiable";
  Listing: "Identifiable" | "Resource";
  NFT: "BlockchainEntity" | "Identifiable";
  NFTFile: "File";
  NFTModel:
    | "BlockchainEntity"
    | "BlockchainResource"
    | "Identifiable"
    | "Resource";
  NFTSet:
    | "BlockchainEntity"
    | "BlockchainResource"
    | "Identifiable"
    | "Resource";
  Org: "Identifiable";
  Package: "Identifiable";
  PackagingModel: "Identifiable" | "Resource";
  SimpleFile: "File";
  Wallet: "Identifiable";
  BlockchainResource: "BlockchainEntity" | "Resource";
}

export type NexusGenObjectNames = keyof NexusGenObjects;

export type NexusGenInputNames = keyof NexusGenInputs;

export type NexusGenEnumNames = keyof NexusGenEnums;

export type NexusGenInterfaceNames = keyof NexusGenInterfaces;

export type NexusGenScalarNames = keyof NexusGenScalars;

export type NexusGenUnionNames = keyof NexusGenUnions;

export type NexusGenObjectsUsingAbstractStrategyIsTypeOf = never;

export type NexusGenAbstractsUsingStrategyResolveType = never;

export type NexusGenFeaturesConfig = {
  abstractTypeStrategies: {
    resolveType: false;
    isTypeOf: false;
    __typename: true;
  };
};

export interface NexusGenTypes {
  context: any;
  inputTypes: NexusGenInputs;
  rootTypes: NexusGenRootTypes;
  inputTypeShapes: NexusGenInputs & NexusGenEnums & NexusGenScalars;
  argTypes: NexusGenArgTypes;
  fieldTypes: NexusGenFieldTypes;
  fieldTypeNames: NexusGenFieldTypeNames;
  allTypes: NexusGenAllTypes;
  typeInterfaces: NexusGenTypeInterfaces;
  objectNames: NexusGenObjectNames;
  inputNames: NexusGenInputNames;
  enumNames: NexusGenEnumNames;
  interfaceNames: NexusGenInterfaceNames;
  scalarNames: NexusGenScalarNames;
  unionNames: NexusGenUnionNames;
  allInputTypes:
    | NexusGenTypes["inputNames"]
    | NexusGenTypes["enumNames"]
    | NexusGenTypes["scalarNames"];
  allOutputTypes:
    | NexusGenTypes["objectNames"]
    | NexusGenTypes["enumNames"]
    | NexusGenTypes["unionNames"]
    | NexusGenTypes["interfaceNames"]
    | NexusGenTypes["scalarNames"];
  allNamedTypes:
    | NexusGenTypes["allInputTypes"]
    | NexusGenTypes["allOutputTypes"];
  abstractTypes: NexusGenTypes["interfaceNames"] | NexusGenTypes["unionNames"];
  abstractTypeMembers: NexusGenAbstractTypeMembers;
  objectsUsingAbstractStrategyIsTypeOf: NexusGenObjectsUsingAbstractStrategyIsTypeOf;
  abstractsUsingStrategyResolveType: NexusGenAbstractsUsingStrategyResolveType;
  features: NexusGenFeaturesConfig;
}

declare global {
  interface NexusGenPluginTypeConfig<TypeName extends string> {}
  interface NexusGenPluginInputTypeConfig<TypeName extends string> {}
  interface NexusGenPluginFieldConfig<
    TypeName extends string,
    FieldName extends string
  > {}
  interface NexusGenPluginInputFieldConfig<
    TypeName extends string,
    FieldName extends string
  > {}
  interface NexusGenPluginSchemaConfig {}
  interface NexusGenPluginArgConfig {}
}
